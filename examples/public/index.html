<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Screen Capture Stream</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background-color: #1a1a1a;
        color: white;
        font-family: sans-serif;
      }
      #fps {
        position: absolute;
        top: 20px;
        left: 20px;
        padding: 8px 16px;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 4px;
        font-weight: bold;
        pointer-events: none; /* Let clicks pass through */
      }
      #stream {
        max-width: 100%;
        max-height: 100vh;
        object-fit: contain;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }
    </style>
  </head>
  <body>
    <div id="fps">FPS: 0</div>
    <canvas id="stream"></canvas>

    <script>
      const fpsEl = document.getElementById('fps')
      const canvasEl = document.getElementById('stream')
      let wsClient = null
      let worker = null
      let mainCtx = null
      let mainDecoding = false
      let mainPending = null

      // FPS Calculation
      let frameCount = 0
      let lastTime = performance.now()

      function updateFPS() {
        const now = performance.now()
        const delta = now - lastTime

        if (delta >= 1000) {
          const fps = Math.round((frameCount * 1000) / delta)
          fpsEl.textContent = `FPS: ${fps}`
          frameCount = 0
          lastTime = now
        }

        requestAnimationFrame(updateFPS)
      }

      updateFPS()

      function connect() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
        const ws = new WebSocket(`${protocol}//${window.location.host}`)
        wsClient = ws

        ws.binaryType = 'arraybuffer'

        ws.onopen = () => {
          console.log('Connected - Receiving Stream')
          setupWorker()
          setupInputListeners()
        }

        ws.onmessage = (event) => {
          if (worker && event.data instanceof ArrayBuffer) {
            worker.postMessage({ type: 'frame', data: event.data }, [event.data])
          } else if (event.data instanceof ArrayBuffer) {
            mainPending = event.data
            if (!mainDecoding) {
              mainDecoding = true
              decodeInMain()
            }
          }
        }

        ws.onclose = () => {
          console.log('Disconnected - Reconnecting...')
          setTimeout(connect, 3000)
        }

        ws.onerror = (err) => {
          console.error('WebSocket error:', err)
          ws.close()
        }
      }

      function setupInputListeners() {
        if (!canvasEl) return

        // Mouse Move
        canvasEl.addEventListener('mousemove', (e) => {
          sendEvent({
            type: 'mousemove',
            x: e.clientX, // Note: This needs coordinate mapping if image is scaled
            y: e.clientY,
          })
        })

        // Mouse Click
        canvasEl.addEventListener('mousedown', (e) => {
          sendEvent({
            type: 'mousedown',
            button: e.button === 0 ? 'left' : e.button === 2 ? 'right' : 'middle',
          })
        })

        canvasEl.addEventListener('mouseup', (e) => {
          sendEvent({
            type: 'mouseup',
            button: e.button === 0 ? 'left' : e.button === 2 ? 'right' : 'middle',
          })
        })

        // Double Click
        canvasEl.addEventListener('dblclick', (e) => {
          sendEvent({
            type: 'dblclick',
            button: 'left', // dblclick usually implies left button
          })
        })

        // Prevent context menu on right click
        canvasEl.addEventListener('contextmenu', (e) => e.preventDefault())

        // Keyboard
        window.addEventListener('keydown', (e) => {
          // Map JS key codes to RobotJS keys if necessary
          // For simplicity, passing key name directly (needs normalization for robust use)
          const key = mapKey(e.key)
          if (key) {
            sendEvent({ type: 'keydown', key })
          }
        })

        window.addEventListener('keyup', (e) => {
          const key = mapKey(e.key)
          if (key) {
            sendEvent({ type: 'keyup', key })
          }
        })
      }

      function mapKey(key) {
        // Basic mapping, RobotJS uses specific strings
        const map = {
          ArrowUp: 'up',
          ArrowDown: 'down',
          ArrowLeft: 'left',
          ArrowRight: 'right',
          Enter: 'enter',
          Backspace: 'backspace',
          Escape: 'escape',
          Tab: 'tab',
          Control: 'control',
          Shift: 'shift',
          Alt: 'alt',
          Meta: 'command',
        }
        if (map[key]) return map[key]
        if (key.length === 1) return key.toLowerCase()
        return null
      }

      function sendEvent(event) {
        if (wsClient && wsClient.readyState === WebSocket.OPEN) {
          // Scale coordinates if image is resized via CSS
          if (event.x !== undefined && event.y !== undefined) {
            const rect = canvasEl.getBoundingClientRect()
            const scaleX = canvasEl.width / rect.width
            const scaleY = canvasEl.height / rect.height
            event.x = Math.round((event.x - rect.left) * scaleX)
            event.y = Math.round((event.y - rect.top) * scaleY)
          }
          wsClient.send(JSON.stringify(event))
        }
      }

      function setupWorker() {
        if (worker) return
        if (!('OffscreenCanvas' in window)) {
          mainCtx = canvasEl.getContext('2d', { alpha: false, desynchronized: true })
          return
        }

        const offscreen = canvasEl.transferControlToOffscreen()
        worker = new Worker('decoder-worker.js')
        worker.postMessage({ type: 'init', canvas: offscreen }, [offscreen])
        worker.onmessage = (e) => {
          const msg = e.data
          if (msg?.type === 'frame') {
            frameCount++
          }
        }
      }

      connect()

      async function decodeInMain() {
        try {
          while (mainPending) {
            const buf = mainPending
            mainPending = null

            const blob = new Blob([buf], { type: 'image/jpeg' })
            const bitmap = await createImageBitmap(blob)

            if (canvasEl.width !== bitmap.width || canvasEl.height !== bitmap.height) {
              canvasEl.width = bitmap.width
              canvasEl.height = bitmap.height
            }

            if (mainCtx) {
              mainCtx.drawImage(bitmap, 0, 0)
              frameCount++
            }

            bitmap.close()
          }
        } catch (e) {
          console.error('Decode error:', e)
        } finally {
          mainDecoding = false
        }
      }
    </script>
  </body>
</html>
